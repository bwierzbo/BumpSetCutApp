---
epic: debugdashboard
number: 004
title: Data Persistence - Video Metadata Extension
status: closed
created: 2025-09-03T16:52:09Z
depends_on: [002]
parallel: false
conflicts_with: []
effort: M
estimate_days: 2
batch: data-testing
---

# Task 004: Data Persistence - Video Metadata Extension

## Overview

Extend the video metadata system to support debug data storage and lifecycle management. Implement debug data cleanup when videos are deleted and ensure session persistence across app restarts. This task creates the foundation for long-term debug data management and ensures data integrity throughout the application lifecycle.

## Context

This task depends on Task 002's debug data collection functionality. It extends the existing MediaStore and video metadata structures to handle debug-specific data persistence, ensuring debug sessions can survive app restarts and maintaining data consistency when videos are managed.

## Technical Details

**Files to Modify:**
- `Data/Storage/MediaStore.swift` - Extend for debug data storage and lifecycle
- `Domain/Models/VideoMetadata.swift` - Add debug data fields and relationships
- `Infrastructure/Services/VideoProcessor.swift` - Integrate debug data persistence

**Data Architecture:**

**1. VideoMetadata Extension**
```swift
// Extend VideoMetadata to include debug information
extension VideoMetadata {
    // Debug-specific fields
    var debugDataAvailable: Bool { return debugSessionId != nil }
    var debugSessionId: UUID?
    var debugDataPath: String?
    var debugCollectionDate: Date?
    var debugDataSize: Int64?
    
    // Debug data lifecycle methods
    func attachDebugData(sessionId: UUID, dataPath: String, size: Int64) {
        self.debugSessionId = sessionId
        self.debugDataPath = dataPath
        self.debugCollectionDate = Date()
        self.debugDataSize = size
    }
    
    func clearDebugData() {
        self.debugSessionId = nil
        self.debugDataPath = nil
        self.debugCollectionDate = nil
        self.debugDataSize = nil
    }
}
```

**2. MediaStore Debug Extensions**
```swift
// Add debug-specific storage methods to MediaStore
extension MediaStore {
    // Save debug data for video
    func saveDebugData(
        for videoId: UUID,
        debugData: DebugData,
        sessionId: UUID
    ) async throws -> String {
        let debugPath = generateDebugDataPath(videoId: videoId, sessionId: sessionId)
        try await persistDebugData(debugData, to: debugPath)
        
        // Update video metadata
        if var metadata = await getVideoMetadata(videoId: videoId) {
            metadata.attachDebugData(
                sessionId: sessionId,
                dataPath: debugPath,
                size: debugData.estimatedSize
            )
            try await updateVideoMetadata(metadata)
        }
        
        return debugPath
    }
    
    // Load debug data for video
    func loadDebugData(for videoId: UUID) async throws -> DebugData? {
        guard let metadata = await getVideoMetadata(videoId: videoId),
              let debugPath = metadata.debugDataPath else {
            return nil
        }
        
        return try await loadPersistedDebugData(from: debugPath)
    }
    
    // Clean up debug data when video deleted
    func deleteVideoWithDebugData(videoId: UUID) async throws {
        // Load metadata to get debug data path
        if let metadata = await getVideoMetadata(videoId: videoId),
           let debugPath = metadata.debugDataPath {
            try await deleteDebugDataFile(at: debugPath)
        }
        
        // Delete video using existing method
        try await deleteVideo(videoId: videoId)
    }
}
```

**3. Debug Data Persistence Format**
```swift
// Serializable debug data structure
struct PersistentDebugData: Codable {
    let sessionId: UUID
    let collectionDate: Date
    let videoId: UUID
    let frameAnalysis: [FrameDebugData]
    let trajectoryData: TrajectoryDebugData
    let performanceMetrics: PerformanceDebugData
    let processingParameters: ProcessingParametersData
    
    var estimatedSize: Int64 {
        // Calculate approximate storage size
        return Int64(frameAnalysis.count * 1024 + 2048) // Rough estimate
    }
}
```

## Data Flow Architecture

**Debug Data Lifecycle:**
1. Video processed with debug mode → Debug data collected
2. Processing completes → `MediaStore.saveDebugData()` called
3. Debug data serialized and saved to persistent storage
4. VideoMetadata updated with debug data references
5. App restart → Debug data automatically available via metadata
6. Video deletion → Debug data cleaned up automatically

**Storage Strategy:**
- Debug data stored in application documents directory
- Organized by video ID and session ID for easy cleanup
- JSON serialization for cross-platform compatibility
- Metadata references maintain data relationships

## Performance Considerations

**Storage Efficiency:**
- Compress debug data before persistence (target: 50% size reduction)
- Lazy loading of debug data (only when dashboard accessed)
- Background serialization to avoid UI blocking
- Storage quota management (cleanup old debug data if needed)

**Memory Management:**
- Stream large debug data sets during serialization
- Release debug data from memory after persistence
- Weak references to prevent retention cycles
- Periodic cleanup of orphaned debug files

## Acceptance Criteria

### VideoMetadata Extension
- [ ] VideoMetadata includes debug-specific fields (sessionId, dataPath, date, size)
- [ ] `debugDataAvailable` computed property correctly indicates debug data presence
- [ ] Debug data attachment and cleanup methods implemented
- [ ] Metadata properly serializes with debug fields included

### MediaStore Debug Integration
- [ ] `saveDebugData()` method persists debug data and updates metadata
- [ ] `loadDebugData()` method retrieves debug data from storage
- [ ] `deleteVideoWithDebugData()` method cleans up debug data during video deletion
- [ ] Debug data file paths generated consistently and uniquely

### Debug Data Persistence
- [ ] PersistentDebugData structure includes all necessary debug information
- [ ] JSON serialization/deserialization works correctly
- [ ] Debug data files created with proper permissions and location
- [ ] File cleanup occurs when videos deleted or app storage managed

### Session Persistence
- [ ] Debug data survives app restarts and is accessible
- [ ] Debug dashboard can load previously collected debug data
- [ ] Metadata relationships maintained across app sessions
- [ ] No data corruption or loss during persistence operations

### Storage Management
- [ ] Debug data storage size estimated and tracked
- [ ] Orphaned debug files detected and cleaned up
- [ ] Storage usage within reasonable limits (configurable quota)
- [ ] Background persistence doesn't block UI operations

## Definition of Done

1. **Persistence Infrastructure Complete**: Debug data can be saved to and loaded from persistent storage
2. **Metadata Integration Working**: VideoMetadata correctly tracks debug data availability and location
3. **Lifecycle Management Implemented**: Debug data properly cleaned up when videos deleted
4. **Session Persistence Functional**: Debug data accessible across app restarts
5. **Storage Efficiency Optimized**: Debug data compressed and managed efficiently
6. **Ready for Export Features**: Persistent debug data prepared for Task 005 export functionality

## Dependencies

**Requires Task 002**: Needs debug data collection working to have data to persist
**Enables Task 005**: Provides persistent debug data for export functionality
**Enables Task 006**: Provides data persistence for comprehensive testing

## Technical Notes

- Leverage existing MediaStore architecture for consistency
- Consider future scalability - debug data may grow significantly
- Implement versioning for debug data format compatibility
- Error handling for storage failures should be robust
- Performance monitoring during persistence operations recommended