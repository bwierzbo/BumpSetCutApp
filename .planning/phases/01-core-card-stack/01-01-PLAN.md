---
phase: 01-core-card-stack
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - BumpSetCut/Features/CardStack/Models/CardStackItem.swift
  - BumpSetCut/Features/CardStack/Models/CardStackAction.swift
  - BumpSetCut/Features/CardStack/CardStackViewModel.swift
autonomous: true

must_haves:
  truths:
    - "Card stack state tracks current position in deck"
    - "Card stack identifies which cards are visible for rendering"
    - "Card stack records user actions (save/remove) per card"
  artifacts:
    - path: "BumpSetCut/Features/CardStack/Models/CardStackItem.swift"
      provides: "Generic Identifiable card data structure"
      min_lines: 15
    - path: "BumpSetCut/Features/CardStack/Models/CardStackAction.swift"
      provides: "Swipe action types (save/remove)"
      min_lines: 10
    - path: "BumpSetCut/Features/CardStack/CardStackViewModel.swift"
      provides: "Observable state manager with visible stack logic"
      exports: ["CardStackViewModel"]
      min_lines: 60
  key_links:
    - from: "CardStackViewModel"
      to: "CardStackItem"
      via: "Array property with Identifiable tracking"
      pattern: "var cards: \\[CardStackItem\\]"
    - from: "CardStackViewModel"
      to: "visibleCardIndices computed property"
      via: "Position-based visibility calculation"
      pattern: "var visibleCardIndices: \\[Int\\]"
---

<objective>
Create generic card stack data models and state management foundation that supports swipeable card UI without coupling to video playback.

Purpose: Establish reusable card stack architecture that Phase 2 can extend with video players while maintaining separation of concerns. This mirrors existing RallyPlayerViewModel pattern but extracts generic card behavior.

Output: Working @Observable view model that tracks card position, visible indices, and user actions with stable identifier-based card management.
</objective>

<execution_context>
@/Users/benjaminwierzbanowski/.claude/get-shit-done/workflows/execute-plan.md
@/Users/benjaminwierzbanowski/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-core-card-stack/01-RESEARCH.md

# Existing patterns to follow
@BumpSetCut/Features/RallyPlayback/RallyPlayerViewModel.swift
@BumpSetCut/Features/RallyPlayback/Models/RallyAction.swift
@BumpSetCut/DesignSystem/Tokens/AnimationTokens.swift
</context>

<tasks>

<task type="auto">
  <name>Create CardStackItem and CardStackAction Models</name>
  <files>
    BumpSetCut/Features/CardStack/Models/CardStackItem.swift
    BumpSetCut/Features/CardStack/Models/CardStackAction.swift
  </files>
  <action>
Create generic card stack models in new Features/CardStack/Models/ directory:

**CardStackItem.swift:**
- Struct conforming to `Identifiable` with stable `UUID` id
- Generic `content` property (placeholder for Phase 2 video URLs)
- Optional `action: CardStackAction?` to track user decision
- Follow existing RallyAction.swift pattern but make generic

**CardStackAction.swift:**
- Enum with cases: `.save`, `.remove`
- Mirror existing RallySwipeAction but without video-specific coupling
- Include `Equatable` conformance for state comparison

Use existing codebase conventions:
- File headers matching BumpSetCut style
- SwiftUI imports where needed
- Foundation imports for UUID/Identifiable

Do NOT duplicate RallyAction types - create new generic versions suitable for any card content.
  </action>
  <verify>
```bash
# Files exist at correct paths
ls BumpSetCut/Features/CardStack/Models/CardStackItem.swift
ls BumpSetCut/Features/CardStack/Models/CardStackAction.swift

# Build succeeds
xcodebuild -project BumpSetCut.xcodeproj -scheme BumpSetCut -destination 'platform=iOS Simulator,name=iPhone 16 Pro' build
```
  </verify>
  <done>
CardStackItem struct exists with UUID id and Identifiable conformance. CardStackAction enum exists with save/remove cases. Project builds without errors.
  </done>
</task>

<task type="auto">
  <name>Create CardStackViewModel with Identifier-Based Stack Management</name>
  <files>
    BumpSetCut/Features/CardStack/CardStackViewModel.swift
  </files>
  <action>
Create @Observable view model following RallyPlayerViewModel pattern (lines 7-114) with generic card stack logic:

**State properties:**
- `var cards: [CardStackItem]` - Main card array (Identifiable tracking)
- `private(set) var currentIndex: Int = 0` - Current card position
- `private(set) var visibleCardIndices: [Int] = []` - Indices for rendering
- `var dragOffset: CGSize = .zero` - Gesture tracking
- `var dragRotation: Double = 0` - Rotation during drag
- `private let forwardStackSize = 2` - Show 2 cards ahead
- `private let backwardStackSize = 1` - Keep 1 card behind for undo

**Computed properties:**
- `var canGoNext: Bool` - Check if more cards available
- `var currentCard: CardStackItem?` - Current card (safe access)
- `var totalCards: Int` - Total count

**Core methods:**
- `func updateVisibleStack()` - Calculate visible indices based on currentIndex (follow RallyPlayerViewModel lines 93-109)
- `func stackPosition(for cardIndex: Int) -> Int` - Return position relative to current (-1, 0, 1+)
- `func zIndexForPosition(_ position: Int) -> Double` - Explicit zIndex calculation (0=100, 1+=-position, prevents animation glitches per research Pitfall 1)
- `func performAction(_ action: CardStackAction)` - Record action, advance to next card
- `init(cards: [CardStackItem])` - Initialize with card array

Use @Observable macro (iOS 17+, not @ObservableObject). Follow existing pattern exactly but remove video-specific logic (no AVPlayer, no rally segments).

CRITICAL: Use identifier-based tracking (Identifiable protocol) not array indices to prevent animation glitches (research Pattern 1).
  </action>
  <verify>
```bash
# File exists
ls BumpSetCut/Features/CardStack/CardStackViewModel.swift

# Contains @Observable macro
grep -n "@Observable" BumpSetCut/Features/CardStack/CardStackViewModel.swift

# Contains zIndex calculation
grep -n "func zIndexForPosition" BumpSetCut/Features/CardStack/CardStackViewModel.swift

# Build succeeds
xcodebuild -project BumpSetCut.xcodeproj -scheme BumpSetCut -destination 'platform=iOS Simulator,name=iPhone 16 Pro' build
```
  </verify>
  <done>
CardStackViewModel class exists with @Observable macro, visibleCardIndices computed property, stackPosition/zIndexForPosition methods, and performAction method. Project builds without errors.
  </done>
</task>

</tasks>

<verification>
After all tasks complete:

1. **Models exist and are generic:**
   ```bash
   # Check CardStackItem has UUID id
   grep "id: UUID" BumpSetCut/Features/CardStack/Models/CardStackItem.swift

   # Check CardStackAction has save/remove cases
   grep "case save" BumpSetCut/Features/CardStack/Models/CardStackAction.swift
   ```

2. **ViewModel follows @Observable pattern:**
   ```bash
   # No @Published properties (that's @ObservableObject pattern)
   ! grep "@Published" BumpSetCut/Features/CardStack/CardStackViewModel.swift

   # Has explicit zIndex calculation
   grep "zIndexForPosition" BumpSetCut/Features/CardStack/CardStackViewModel.swift
   ```

3. **Architecture matches research recommendations:**
   - Identifiable protocol used for card tracking (not indices)
   - Explicit zIndex calculation prevents animation glitches
   - State management separated from UI concerns
</verification>

<success_criteria>
- [ ] CardStackItem struct conforms to Identifiable with UUID
- [ ] CardStackAction enum has save and remove cases
- [ ] CardStackViewModel uses @Observable macro (not @ObservableObject)
- [ ] visibleCardIndices computed property returns indices for current + next 2 cards
- [ ] zIndexForPosition method returns explicit values (100 for current, negative for rest)
- [ ] performAction method records action and advances currentIndex
- [ ] Project builds successfully on iOS Simulator
- [ ] No compiler warnings in new files
</success_criteria>

<output>
After completion, create `.planning/phases/01-core-card-stack/01-01-SUMMARY.md`
</output>
